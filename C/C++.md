```mermaid
flowchart LR
Start --> Stop
```

### C++ 与 c不同
1. 基本数据类型 多个 bool  1byte true 为1  false 为 0
2. 引用类型多一个类 class
3. 函数
	1. **引用** 相当于变量的别名 int& a = b ; a与b指向同一个内存空间 引用在声明的同时初始化 初始化后不能再修改指向其他的内存空间   引用作为函数形参时，当函数被调用时才为引用分配内存空间，函数内部操作的也是引用指向的内存空间，与普通的值传递不同
	2. **内联函数** 普通函数前加上inline 关键字 作用类似于#define 定义的宏函数 在函数编译时直接替换到调用的位置而不是跳转 。这类函数要求简单 而且看编译器 编译器不一定把inline 修饰的函数就当作内联函数编译
	3. **带默认形参值的函数** int add(int x = 5, int y = 6){return x+y} 调用时如果不传递参数就会使用默认的参数
		1. 有默认值的形参的右边不能出现无默认值的形参
		2. 在相同作用域内，不允许在同一个函数的多个生明中对同一个参数的默认值重复定义，及时前后定义的值相同也不行
	4. **函数重载** c不支持重载 c中函数即指针c中只凭借函数名匹配 c++支持函数重载：函数名相同但是形参的个数或者类型不同，编译器根据函数的实参和形参的个数以及名称匹配决定调用哪个函数  **编译器不以函数返回值类型不同来区分函数** 所以同名但是返回值不同的函数不是重载 有问题
	5. c++ 在调用函数前必须对函数进行声明 对函数进行完整的声明编译器才不会出错
4. 类 对象
	1. abstract
	2. encapsulation
	3. expand
	4. 多态：同一段程序能够处理多种类型的对象的能力
		1. 强制多态：将一种类型的数据转换成另一种类型的数据处理 （隐式或显示）
		2. 重载多态  函数的重载 运算符重载
		3. 类型参数化多态  模板
		4. 包含多态 虚函数
	5. 类成员的访问控制
		1. public 提供给外部类访问的接口
		2. protected  类以及继承的类可以访问
		3. private:私有成员只有本类的内部成员才可以访问
	6. 类的成员函数
		1.  实现 在类里面声明 在类外部实现 class:: 函数名
		2. 对象.函数名（参数）调用
		3. 带默认参数值的成员函数
		4. 内联成员函数
			1. 隐式声明：将函数体直接放在类体内
			2. 显式声明：inline
	7. 构造函数与析构函数
		1. **构造函数**对对象进行初始化  分配内存空间
			1. 构造函数名称与类名相同 没有返回值 构造函数通常被声明为公有函数。只要类中有了构造函数，编译器就会在建立新对象的地方自动插入对构造函数调用的代码。构造函数在对象被创建时自动调用。
			2. 如果类中没有写构造函数，编译器会自动生成一个隐含的默认构造函数，该构造函数的函数体和参数列表都为空。如果类中声明了构造函数，那么编译器就不会再生成默认的构造函数。
			3. 复制构造函数，其形参是本类对象的引用。作用是使用一个已经初始化的本类对象，去初始化一个一模一样的同类新对象。复制构造函数在下面3中情况下均会被调用：
				1. 用一个类对象去初始化另一个同类对象时
				2. 类对象作为函数的形参时
				3. 函数的返回值是类对象，返回函数时，调用复制构造函数
			4. 复制构造函数： 类名（类名 &  标识符）
		2. 析构函数对对象进行内存释放，析构函数在对象的生存期即将结束的时刻被自动调用
			1. 类的共有成员函数，他的名称时由类名前+~ 无返回值 无形参
	8. 类的组合
		1. 类的成员是其他类对象
	9. 向前引用声明
			1. 向前引用声明，是在引用未定义的类之前，将该类的名字告诉编译器，使编译器知道那是一个类名。这样当程序使用这个类名时，就不会认为是错误的。class B; 类似于extern?
		1. UML(Unified Modeling Language)
	10. 结构体
		1. c++中的结构体与c中结构体不同 c++中结构体是一种特殊的类 与类的不同之处在如果不标注则默认访问权限为public 类的默认访问权限为pravite  可以完全用class代替
	11. 联合体
		1. 联合体也是一种特殊形式的类   默认访问控制属性为public  联合体的全部数据成员共享同一组内存单元 联合体不能继承也不支持多态 union
5. 标识符的作用域与可见性
	1. 作用域
		1. 函数原型作用域
		2. 局部作用域
		3. 类作用域
		4. 命名空间作用域 需要用 命名空间名：：标识符 using namespace  命名空间名 将制定的命名空间内的所有标识符暴露在电钢琴啊的作用域内，使得当前作用域中可以直接引用该命名空间内的任何标识符   c++标准程序库的所有标识符都被声明在std命名空间内
			1. 全局命名空间 没有显式声明的命名空间之外声明的标识符都在一个全局命名空间中
			2. 匿名命名空间是一个需要显式声明的没有名字的命名空间 namespace { }  
				1. 匿名空间里的内容只能被本文件调用，不能被其他文件调用
				2. 全局命名空间中可以直接使用名称调用匿名命名空间中的标量
	2. 对象的生存期
		1. 静态生存期：生命周期与程序的运行周期相同
			1. 命名空间作用域中声明的对象
			2. static修饰的
		2. 动态生存期： 静态生存期之外的
			1. 类的成员对象也有各自的生存期，不用static修饰的成员对象，其生存期都与他们所属对象的生存期保持一致
	3. 类的静态成员
		1. 类的静态数据成员  static 只初始化一次 所有的类对象共享这一块内存空间
		2. 类的静态数据成员访问方法 可直接使用*类名：：标识符访问*
		3. 类的静态函数成员：静态成员函数也属于整个类  由同一个类的所有成员共享
	4. 友员关系：一个类主动声明哪些其他类或函数是它的朋友，进而给他们提供对本类的访问许可。通过友元关系，一个普通函数或者类的成员函数可以访问另一个封装于另一个类中的数据（protected pravite)
		1. 友元函数 在类中 friend 修饰的函数声明 用于声明这个函数是类的友元函数  函数体在类外部实现 函数内部可以通过类对象.引用私有成员
		2. 友元类  在类A内部声明 fiend Class B .则B的所有成员函数都是B类的友元函数  B类的成员函数都可以访问A类的私有和保护成员 
	5. 共享数据的保护
		1. 常对象: const 类名 对象名 ：它的数据成员值在整个生存期间内不能被改变
		2. const修饰的类成员
			1. 常成员函数：目的对象被视为常对象 不能更新目的对象的成员
			2. 常对象只能调用常成员函数，不能调用其他成员函数
			3. const 关键字修饰函数可以作为重载区分
			4. 常数据成员 如果在一个类中说明了常数据成员 那么任何函数中都不能对该成员赋值：const int A::b =10: 静态常数据成员在类外说明和初始化
			5. 类的静态变量和常量都应该在类外加以定义
		3. 常引用 const 数据类型 & 引用名
			1. 常对象只能绑定常引用
			2. 常引用既能绑定常对象又能非常对象，但是通过常引用访问时 无论是否为常对象都视为常对象
			3. 常引用作为函数参数时，既不会进行参数传递 同时还能保护参数不会被改变
		4. 外部变量和外部函数
		5. this指针 this指针式一个隐含于每一个类的非静态成员函数中的特殊指针（包括构造函数和析构函数），它用于指向正在被成员函数操作的对象。
	6. 引用 int & r   可以作为常量或者变量的另一个别名 **不占用存储空间**
		1. 引用作为函数参数时，不进行参数的传递
		2. 常引用作为函数参数
		3. 引用作为函数返回值
	7. 动态分配内存 在堆上 new delete
		1. 基础类型数剧 int * p = new int(3); delete p;
		2. 动态创建对象 Point * ptr = new Point()
		3. 动态创建数组 int * p = new int\[10]() ; delete[] p;
		4. vecter/<double>arr[3,2.1]; arr.size();
	8. 深复制 浅复制
		1. 当类有指针成员时，使用默认的复制函数，两个对象的指针都指向同一片区域，对其中一个对象指针所指向的区域修改也会导致另一个对象变化
6. 类的继承和派生
	1. Class A : pravite Class B , public Class C
	2. 继承方式规定了如何访问从基类继承的成员 public private protected 不显式的给出继承方式则默认private
		1. 当类的继承方式为公有继承时，基类的公有成员和保护成员的访问属性在派生类中不变，基类的私有成员不可直接访问。成员访问属性不变，派生类中可以访问public protected 成员，派生类对象只能访问 public成员
		2. 私有继承，基类中的公有成员和保护成员都以私有成员身份出现在派生类中，而基类的私有成员在派生类中不可直接访问。
		3. 保护继承 基类的共有成员和保护成员都以保护成员的身份出现在派生类中，基类的私有成员不可直接访问。
	3. 派生类继承了积累全部数据成员除了构造和析构函数之外的全部函数成员
	4. 类型兼容规则 ：在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。
		1. 派生类对象可以隐式的转换位基类对象 b1 = d1;
		2. 派生类对象可以初始化基类对象的引用
		3. 派生类的指针可以隐式的转换为基类的指针。
		4. 如此以来就可以使用基类来泛指所有的公共派生类，但是只能通过基类对象访问从基类继承的成员
	5. 派生类的构造函数和析构函数
		1. 构造函数 Dervied:Derived(int a ,int b ,int c ,int d) :Base(a),Base(b),member(1),member(d)
			1. 调用基类构造函数，调用顺序按照他们被继承时声明的顺序
			2. 对派生类新增的成员对象初始化，调用顺序按照他们在类中声明的顺序。
			3. 执行派生类的构造函数体的内容。
		2. 复制函数
			1. Derived::Derived(const Derived &v):Base1(v)Base2(v
		3. 析构函数和构造函数的顺序完全反过来
	6. 派生类成员的标识与访问
		1. 如果派生类中声明了与基类成员函数同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏。
		2. 如果派生类的多个基类拥有同名成员，派生类没有新增同名成员，这时只能通过基类名和作用域分辨符来访问基类同名成员。d.Base::var
		3. using Base1:fun 可以在派生类中实现函数重载
	7. 虚基类
		1. 将共同基类设置为虚基类，这时从不同路径继承过来的同名数据成员在内存咋哄就只有一个副本，同一个函数名也就只有一个映射 class 派生类名：vistual 继承方式 基类名
		2. 声明了虚基类之后，虚基类的成员在进一步派生过程中和派生类一起维护同一个内存数据副本
7. 多态性
	1. 多态指的是同样的消息被不同的类型的对象接收时会有不同的同坐
	2. 多态性分为4类：重载多态 强制多态 包含多态 参数多态
	3. 运算符重载：对已有的运算符赋予多重含义，使同一个运算符作用于不同类型的数据时导致不同的行为
		1. 成员函数 运算符重载
		2. 非成员函数运算符重载
	4. 一般虚函数成员
		1. virtual 函数类型 函数名（形参表)；
	5. 抽象类
		1. 有虚函数的的类